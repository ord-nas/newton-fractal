<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="static/jquery-ui.css">
        <script src="static/jquery-3.2.1.min.js"></script>
	<script src="static/jquery-ui.js"></script>
        <style type="text/css">
         #viewport {
             display: grid;
             grid-template: 1fr / 1fr;
             place-items: start;
         }
         #viewport > * {
             grid-column: 1 / 1;
             grid-row: 1 / 1;
         }
         #overlay {
             z-index: 2;
         }
         #fractal {
             object-fit: none;
             z-index: 1;
         }
         #resize_container {
             position: relative;
             z-index: 3;
         }
         #resize_target {
             position: absolute;
             left: 2000px;
             top: 1200px;
             cursor: nwse-resize;
             width: 10px;
             height: 10px;
             background: grey;
         }
         .form fieldset {
             padding: 0;
             border: 0;
             margin-top: 10px;
         }
         .destructive {
             background: #ff6e6e;
         }
        </style>
        <script>
         var events = [];

         function shallow_equal(a, b) {
             if (a === null && b === null) {
                 return true;
             }

             if (a === null || b === null) {
                 return false;
             }

             if (Object.keys(a).length !== Object.keys(b).length) {
                 return false;
             }

             for (let key of Object.keys(a)) {
                 if (a[key] !== b[key]) {
                     return false;
                 }
             }
             return true;
         }

         function random_zero() {
             return {
                 r: Math.random() * 2.0 - 1,
                 i: Math.random() * 2.0 - 1,
                 red: Math.floor(Math.random() * 255),
                 green: Math.floor(Math.random() * 255),
                 blue: Math.floor(Math.random() * 255),
             };
         }

         function random_color() {
             return {
                 red: Math.floor(Math.random() * 255),
                 green: Math.floor(Math.random() * 255),
                 blue: Math.floor(Math.random() * 255),
             };
         }

         function random_char() {
             return String.fromCharCode(97 + Math.floor(Math.random() * 26));
         }

         function random_string(length) {
             return Array(length).fill().map(random_char).join("");
         }

         function get_bounded_value(element) {
             var value = element.valueAsNumber;
             if (!isFinite(value)) {
                 return element.max;
             } else {
                 return Math.min(element.max, Math.max(element.min, value));
             }
         }

         class FractalRequester {
             constructor(image, tracker) {
                 this.image = image;
                 this.tracker = tracker;
                 this.current_params = this.get_current_params();;
                 this.session_id = random_string(32);
                 this.current_request_id = 1;
                 this.last_fractal_data_id = null;
                 this.last_fractal_viewport_id = null;
                 this.last_fractal_elapsed_time = null;
                 this.last_request_params = {};
                 this.pending_params_request = null;
                 this.last_params_request_time = null;
                 this.pending_fractal_request = null;
                 this.last_fractal_request_time = null;

                 // Add a callback to the tracker.
                 var self = this;
                 tracker.add_callback(() => self.on_change());

                 // Make sure this object gets a tick every frame.
                 const tick_callback = function() {
                     self.tick();
                     window.requestAnimationFrame(tick_callback);
                 }
                 window.requestAnimationFrame(tick_callback);
             }

             on_change() {
                 this.current_params = this.get_current_params();
                 this.maybe_fractal_request();
             }

             get_max_iters() {
                 return get_bounded_value(document.getElementById("max_iters"));
             }

             get_save_scale() {
                 return get_bounded_value(document.getElementById("save_scale"));
             }

             get_current_params() {
                 var tracker_state = this.tracker.get_state();
                 return {
                     // Viewport params.
                     width: this.image.width,
                     height: this.image.height,
                     i_min: tracker_state.viewport.i_min,
                     r_min: tracker_state.viewport.r_min,
                     r_range: tracker_state.viewport.r_range,

                     // Zero params.
                     zero_rs: tracker_state.zeros.map((z) => z.r),
                     zero_is: tracker_state.zeros.map((z) => z.i),
                     zero_reds: tracker_state.zeros.map((z) => z.red),
                     zero_greens: tracker_state.zeros.map((z) => z.green),
                     zero_blues: tracker_state.zeros.map((z) => z.blue),

                     // Options.
                     max_iters: this.get_max_iters(),
                     strategy: document.getElementById("strategy").value,
                     precision: document.getElementById("precision").value,
                     png_encoder: document.getElementById("png_encoder").value,
                     handler: document.getElementById("handler").value,
                 };
             }

             max_iters_changed(max_iters) {
                 this.current_params.max_iters = max_iters;
                 this.maybe_fractal_request();
             }

             generate_url_params() {
                 let param_array = [];
                 for (var [key, values] of Object.entries(this.current_params)) {
                     if (!Array.isArray(values)) {
                         values = [values];
                     }
                     for (const value of values) {
                         param_array.push([key, value]);
                     }
                 }
                 // Dump in save params.
                 param_array.push(["save_file", document.getElementById("save_file").value]);
                 param_array.push(["save_scale", this.get_save_scale()]);
                 param_array.push(["save_metadata", JSON.stringify(this.current_params)]);
                 // Dump in load params.
                 param_array.push(["load_file", document.getElementById("load_file").value]);
                 // Dump in identifiers.
                 if (!shallow_equal(this.last_request_params, this.current_params)) {
                     this.current_request_id += 1;
                 }
                 param_array.push(["session_id", this.session_id]);
                 param_array.push(["request_id", this.current_request_id]);
                 param_array.push(["last_data_id",
                                   this.last_fractal_data_id == null ?
                                   0 : this.last_fractal_data_id]);
                 param_array.push(["last_viewport_id",
                                   this.last_fractal_viewport_id == null ?
                                   0 : this.last_fractal_viewport_id]);
                 return new URLSearchParams(param_array);
             }

             tick() {
                 if (document.getElementById("async_params").checked) {
                     this.maybe_params_request();
                 }
             }

             maybe_params_request() {
                 // If we have a pending params request already, nothing to do.
                 if (this.pending_params_request !== null) {
                     return;
                 }

                 // If we don't have a pending fractal request, nothing to do.
                 if (this.pending_fractal_request === null) {
                     return;
                 }

                 // If the last fractal request didn't take at least 50ms, nothing to do.
                 /* if (this.last_fractal_elapsed_time === null ||
                  *     this.last_fractal_elapsed_time < 50) {
                  *     return;
                  * }*/

                 // If the last message we sent (on either channel) wasn't at least 50ms ago, nothing to do.
                 var fractal_time = (this.last_fractal_request_time === null ?
                                     0 : this.last_fractal_request_time);
                 var param_time = (this.last_param_request_time === null ?
                                   0 : this.last_param_request_time);
                 var most_recent = Math.max(fractal_time, param_time);
                 if (Date.now() - most_recent < 50) {
                     return;
                 }

                 // If the params are the same as our previous request, nothing to do.
                 if (shallow_equal(this.last_request_params, this.current_params)) {
                     return;
                 }

                 // Schedule a new request!
                 var url_params = this.generate_url_params();
                 Object.assign(this.last_request_params, this.current_params);
                 // console.log("Params request", this.current_params);
                 this.last_param_request_time = Date.now();
                 this.pending_params_request = fetch("params", {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded'
                     },
                     body: url_params,
                 })
                     .then((response) => {
                         return response.json();
                     })
                     .then((json) => {
                         console.log("Params response", json);
                         this.pending_params_request = null;
                     });
             }

             fractal_up_to_date() {
                 if (this.last_fractal_data_id == null ||
                     this.last_fractal_data_id < this.current_request_id) {
                     return false;
                 }
                 if (this.last_fractal_viewport_id == null ||
                     this.last_fractal_viewport_id < this.current_request_id) {
                     return false;
                 }
                 return true;
             }

             maybe_fractal_request() {
                 // If we have a pending request, nothing to do.
                 if (this.pending_fractal_request !== null) {
                     return;
                 }

                 // If the params are the same as our previous request and we've
                 // already received a fractal with the latest params, nothing to
                 // do.
                 if (this.fractal_up_to_date() &&
                     shallow_equal(this.last_request_params, this.current_params)) {
                     return;
                 }

                 // Schedule a new request!
                 var url_params = this.generate_url_params();
                 Object.assign(this.last_request_params, this.current_params);
                 console.log("Fractal request", this.current_params);
                 this.last_fractal_request_time = Date.now();
                 this.pending_fractal_request = fetch("fractal", {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded'
                     },
                     body: url_params,
                 }).then((response) => {
                     return response.formData();
                 }).then((form_data) => {
                     var metadata = JSON.parse(form_data.get("metadata"));
                     console.log("Fractal response", metadata);
                     this.last_fractal_data_id = metadata["data_id"];
                     this.last_fractal_viewport_id = metadata["viewport_id"];
                     this.last_fractal_elapsed_time = Date.now() - this.last_fractal_request_time;
                     this.pending_fractal_request = null;
                     var blob = form_data.get("fractal_image");
                     const objectURL = URL.createObjectURL(blob);
                     var old_url = this.image.src;
                     this.image.src = objectURL;
                     URL.revokeObjectURL(old_url);
                     this.maybe_fractal_request();
                     compute_fps();
                 });
             }

             save_request() {
                 var url_params = this.generate_url_params();
                 console.log("Save request", Object.fromEntries(url_params));
                 fetch("save", {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded'
                     },
                     body: url_params,
                 }).then((response) => {
                     return response.json();
                 }).then((json) => {
                     console.log("Save response", json);
                     alert("Save response: " +  JSON.stringify(json));
                 });
             }

             save_button() {
                 var self = this;
                 var dialog = $("#save_form");
                 dialog.dialog({
                     buttons: [
                         {
                             text: "Cancel",
                             class: "destructive",
                             click: function() {
                                 dialog.dialog("close");
                             }
                         },
                         {
                             text: "Save",
                             click: function() {
                                 dialog.dialog("close");
                                 self.save_request();
                             }
                         },
                     ],
                 });
                 dialog.dialog("open");
             }

             load_colors(metadata) {
                 var zeros = this.tracker.get_zeros();
                 var N = Math.min(zeros.length,
                                  metadata.zero_reds.length,
                                  metadata.zero_greens.length,
                                  metadata.zero_blues.length);
                 for (var i = 0; i < N; i++) {
                     zeros[i].red = metadata.zero_reds[i];
                     zeros[i].green = metadata.zero_greens[i];
                     zeros[i].blue = metadata.zero_blues[i];
                 }
                 this.tracker.set_zeros(zeros);
             }

             load_full(metadata) {
                 // Compute zeros.
                 var zeros = [];
                 var N = Math.min(metadata.zero_reds.length,
                                  metadata.zero_greens.length,
                                  metadata.zero_blues.length,
                                  metadata.zero_rs.length,
                                  metadata.zero_is.length);
                 for (var i = 0; i < N; i++) {
                     zeros.push({
                         r: metadata.zero_rs[i],
                         i: metadata.zero_is[i],
                         red: metadata.zero_reds[i],
                         green: metadata.zero_greens[i],
                         blue: metadata.zero_blues[i],
                     });
                 }

                 // Set options.
                 document.getElementById("max_iters").value = metadata.max_iters;
                 document.getElementById("strategy").value = metadata.strategy;
                 document.getElementById("precision").value = metadata.precision;
                 document.getElementById("png_encoder").value = metadata.png_encoder;
                 document.getElementById("handler").value = metadata.handler;

                 // Set tracker state.
                 this.tracker.set_state({
                     zeros: zeros,
                     i_min: metadata.i_min,
                     r_min: metadata.r_min,
                     r_range: metadata.r_range,
                     width: metadata.width,
                     height: metadata.height,
                 });

                 // Do an on_change.
                 this.on_change();
             }

             load_request(load_type) {
                 var url_params = this.generate_url_params();
                 console.log("Load request", Object.fromEntries(url_params));
                 fetch("load", {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded'
                     },
                     body: url_params,
                 }).then((response) => {
                     return response.json();
                 }).then((json) => {
                     console.log("Load response", json);
                     if (!json.success) {
                         alert("Load response: " +  JSON.stringify(json));
                         return;
                     }
                     let metadata = JSON.parse(json.metadata);
                     if (load_type == "COLORS") {
                         this.load_colors(metadata);
                     } else {
                         this.load_full(metadata);
                     }
                 });
             }

             load_button() {
                 var self = this;
                 var dialog = $("#load_form");
                 fetch("list_images", {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded'
                     },
                 }).then((response) => {
                     return response.json();
                 }).then((json) => {
                     console.log("List images response", json);
                     if (!json.success) {
                         alert("List images response: " +  JSON.stringify(json));
                         return;
                     }

                     // Populate the list of files that can be loaded.
                     var load_options = document.getElementById("load_file");
                     // Empty out all the existing options.
                     for (var i = load_options.options.length - 1; i >= 0; i--) {
                         load_options.remove(i);
                     }
                     // Add the new options.
                     for (var file of json.images) {
                         var opt = document.createElement('option');
                         opt.value = file;
                         opt.innerHTML = file;
                         load_options.appendChild(opt);
                     }

                     // Pop open the dialog box.
                     dialog.dialog({
                         buttons: [
                             {
                                 text: "Cancel",
                                 class: "destructive",
                                 click: function() {
                                     dialog.dialog("close");
                                 }
                             },
                             {
                                 text: "Load",
                                 click: function() {
                                     dialog.dialog("close");
                                     self.load_request("FULL");
                                 }
                             },
                             {
                                 text: "Load Color Palette",
                                 click: function() {
                                     dialog.dialog("close");
                                     self.load_request("COLORS");
                                 }
                             },
                         ],
                     });
                     dialog.dialog("open");
                 });
             }
         }

         // Origin for both coordinate systems is top left.
         // Pixel coordinates are in the normal pixel sense, positive in the right and down directions.
         // Complex coordinates are in the normal math sense, positive in the right and *up* directions.
         class ViewportTracker {
             constructor(img, canvas, resizer, zeros) {
                 this.img = img;
                 this.canvas = canvas;
                 this.ctx = canvas.getContext("2d");
                 this.resizer = resizer;
                 this.origin_i = 2.5 / canvas.width * canvas.height;
                 this.origin_r = -2.5;
                 this.r_range = 5.0;
                 // Last position of the mouse on this element, in pixels.
                 // Only set when we're in a mouse drag event.
                 this.last_pixels = null;
                 // True if we are in a rotation mouse event.
                 this.rotating = false;
                 // The index of the zero we're currently moving.
                 // Only set when we're in a mouse drag event.
                 // Exactly one of zero_index or last_pixels will be set at a time.
                 this.zero_index = null;
                 // Resize context.
                 // Only set when we're in a resize drag event.
                 this.resize_context = null;
                 // Finetune context.
                 // Only set when a zero is being fine-tuned.
                 this.finetune_context = null;

                 // Current set of zeros.
                 this.zeros = zeros;

                 // Attach canvas event listeners.
                 canvas.addEventListener("mousedown", (event) => this.mousedown(event));
                 canvas.addEventListener("mouseup", (event) => this.mouseup(event));
                 canvas.addEventListener("mousemove", (event) => this.mousemove(event));
                 canvas.addEventListener("wheel", (event) => this.wheel(event));
                 canvas.addEventListener("contextmenu", (event) => {
                     event.stopPropagation();
                     event.preventDefault();
                 });

                 // Attach resizer event listeners.
                 resizer.addEventListener("mousedown", (event) => this.resize_mousedown(event));
                 document.addEventListener("mouseup", (event) => this.resize_mouseup(event));
                 document.addEventListener("mousemove", (event) => this.resize_mousemove(event));

                 // Attach finetune event listeners.
                 document.addEventListener("keydown", (event) => this.keydown(event));

                 // Callbacks when state changes.
                 this.callbacks = [];

                 // Draw the current state.
                 this.draw();
             }

             draw() {
                 // Clear the canvas first.
                 this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                 // Draw circles at each zero location.
                 for (var zero of this.zeros) {
                     // Get the location of this zero.
                     var center = this.complex_to_pixels(zero.r, zero.i);
                     this.ctx.fillStyle = "rgb(255,255,255)";
                     this.ctx.beginPath();
                     this.ctx.arc(center.x, center.y, 11, 0, 2 * Math.PI);
                     this.ctx.fill();
                     this.ctx.fillStyle = "rgb(0,0,0)";
                     this.ctx.beginPath();
                     this.ctx.arc(center.x, center.y, 10, 0, 2 * Math.PI);
                     this.ctx.fill();
                     this.ctx.fillStyle = "rgb(255,255,255)";
                     this.ctx.beginPath();
                     this.ctx.arc(center.x, center.y, 9, 0, 2 * Math.PI);
                     this.ctx.fill();
                     this.ctx.fillStyle = `rgb(${zero.red}, ${zero.green}, ${zero.blue})`;
                     this.ctx.beginPath();
                     this.ctx.arc(center.x, center.y, 8, 0, 2 * Math.PI);
                     this.ctx.fill();
                 }
             }

             get_pixels(event) {
                 var rect = this.canvas.getBoundingClientRect();
                 return {
                     x: event.clientX - rect.left,
                     y: event.clientY - rect.top,
                 };
             }

             get_complex(event) {
                 var pixels = this.get_pixels(event);
                 return {
                     r: this.origin_r + (pixels.x / this.canvas.width * this.r_range),
                     i: this.origin_i - (pixels.y / this.canvas.width * this.r_range),
                 };
             }

             complex_to_pixels(r, i) {
                 return {
                     x: (r - this.origin_r) / this.r_range * this.canvas.width,
                     y: (this.origin_i - i) / this.r_range * this.canvas.width,
                 };
             }

             get_state() {
                 return {
                     zeros: this.zeros,
                     viewport: {
                         i_min: this.origin_i - this.r_range / this.canvas.width * this.canvas.height,
                         r_min: this.origin_r,
                         r_range: this.r_range,
                     }
                 };
             }

             set_state(state) {
                 this.set_size(state.width, state.height);
                 this.r_range = state.r_range;
                 this.origin_r = state.r_min;
                 this.origin_i = state.i_min + state.r_range / state.width * state.height;
                 this.set_zeros(state.zeros);

                 this.draw();
                 this.run_callbacks();
             }

             run_callbacks() {
                 for (var callback of this.callbacks) {
                     callback();
                 }
             }

             get_zero_index(pixels) {
                 for (var i = 0; i < this.zeros.length; i += 1) {
                     // Get the location of this zero.
                     var center = this.complex_to_pixels(this.zeros[i].r, this.zeros[i].i);
                     // Check if we're close enough to this zero.
                     if ((center.x - pixels.x)**2 + (center.y - pixels.y)**2 <= 100) {
                         return i;
                     }
                 }
                 return null;
             }

             mousedown(event) {
                 if (event.which == 3) {
                     this.right_click(event);
                 } else if (event.ctrlKey) {
                     this.ctrl_left_click(event);
                 } else {
                     this.left_click(event);
                 }
             }

             right_click(event) {
                 var pixels = this.get_pixels(event);
                 var zero_index = this.get_zero_index(pixels);
                 if (zero_index !== null) {
                     this.edit_zero(zero_index);
                 } else {
                     this.create_zero(event);
                 }
             }

             edit_zero(zero_index) {
                 var color_picker = document.getElementById("zero_colour");
                 var zero = this.zeros[zero_index];
                 var red = zero.red.toString(16).padStart(2, '0');
                 var green = zero.green.toString(16).padStart(2, '0');
                 var blue = zero.blue.toString(16).padStart(2, '0');
                 color_picker.value = `#${red}${green}${blue}`;
                 color_picker.dataset.zero_index = zero_index;

                 var self = this;
                 var dialog = $("#edit_zero");
                 dialog.dialog({
                     position: {
                         my: "center",
                         at: "center",
                         of: event,
                         collision: "fit",
                     },
                     buttons: [
                         {
                             text: "Delete",
                             class: "destructive",
                             click: function() {
                                 var zeros = self.get_zeros();
                                 if (zeros.length > 1) {
                                     zeros.splice(zero_index, 1);
                                     self.set_zeros(zeros);
                                 }
                                 dialog.dialog("close");
                             }
                         },
                         {
                             text: "Finetune",
                             click: function() {
                                 self.finetune_context = {
                                     zero_index: zero_index,
                                     step_size: 0.125,
                                 };
                                 self.update_finetune_text();
                                 dialog.dialog("close");
                             }
                         },
                     ],
                 });
                 dialog.dialog("open");
             }

             create_zero(event) {
                 var zero = random_color();
                 Object.assign(zero, this.get_complex(event));
                 this.zeros.push(zero);
                 this.set_zeros(this.zeros);
             }

             left_click(event) {
                 this.last_pixels = null;
                 this.zero_index = null;
                 this.resize_context = null;
                 this.rotating = false;

                 var pixels = this.get_pixels(event);
                 var zero_index = this.get_zero_index(pixels);
                 if (zero_index !== null) {
                     this.zero_index = zero_index;
                 } else {
                     this.last_pixels = pixels;
                 }
             }

             ctrl_left_click(event) {
                 this.zero_index = null;
                 this.resize_context = null;

                 this.last_pixels = this.get_pixels(event);
                 this.rotating = true;
             }

             mouseup(event) {
                 this.last_pixels = null;
                 this.zero_index = null;
                 this.resize_context = null;
                 this.rotating = false;
             }

             mousemove(event) {
                 if (this.last_pixels === null && this.zero_index === null) return;

                 if (this.last_pixels !== null && !this.rotating) {
                     var current_pixels = this.get_pixels(event);
                     this.origin_r -= (current_pixels.x - this.last_pixels.x) / this.canvas.width * this.r_range;
                     this.origin_i += (current_pixels.y - this.last_pixels.y) / this.canvas.width * this.r_range;
                     this.last_pixels = current_pixels;
                 } else if (this.last_pixels !== null && this.rotating) {
                     var current_pixels = this.get_pixels(event);
                     var current_angle = Math.atan2(current_pixels.y - this.canvas.height / 2,
                                                    current_pixels.x - this.canvas.width / 2);
                     var last_angle = Math.atan2(this.last_pixels.y - this.canvas.height / 2,
                                                 this.last_pixels.x - this.canvas.width / 2);
                     this.rotate_zeros_about_center(last_angle - current_angle);
                     this.last_pixels = current_pixels;
                 } else {
                     Object.assign(this.zeros[this.zero_index], this.get_complex(event));
                 }

                 this.draw();
                 this.run_callbacks();
             }

             rotate_zeros_about_center(angle) {
                 var center = {
                     r: this.origin_r + this.r_range / 2,
                     i: this.origin_i - this.r_range * this.canvas.height / this.canvas.width / 2,
                 };
                 for (var zero of this.zeros) {
                     this.rotate_zero(zero, center, angle);
                 }
                 this.set_zeros(this.zeros);
             }

             rotate_zero(zero, origin, angle) {
                 var relative = {
                     r: zero.r - origin.r,
                     i: zero.i - origin.i,
                 };
                 var cos_t = Math.cos(angle);
                 var sin_t = Math.sin(angle);
                 var relative_rotated = {
                     r: relative.r * cos_t - relative.i * sin_t,
                     i: relative.r * sin_t + relative.i * cos_t,
                 };
                 zero.r = relative_rotated.r + origin.r;
                 zero.i = relative_rotated.i + origin.i;
             }

             wheel(event) {
                 // Prevent the webpage from scrolling.
                 event.stopPropagation();
                 event.preventDefault();

                 var scale_per_pixel = 0.003;
                 var scale_amount = Math.pow(1 + scale_per_pixel, event.deltaY);
                 var pixels = this.get_pixels(event);
                 var complex = this.get_complex(event);

                 // Adjust the new range based on the scale.
                 this.r_range *= scale_amount;

                 // Figure out how to adjust the origin so that the same point stays under the mouse.
                 this.origin_r = complex.r - pixels.x / this.canvas.width * this.r_range;
                 this.origin_i = complex.i + pixels.y / this.canvas.width * this.r_range;

                 this.draw();
                 this.run_callbacks();
             }

             set_size(new_width, new_height) {
                 this.canvas.width = new_width;
                 this.canvas.height = new_height;
                 this.img.width = new_width;
                 this.img.height = new_height;
                 this.resizer.style.left = new_width + "px";
                 this.resizer.style.top = new_height + "px";
             }

             resize_mousedown(event) {
                 var pixels = this.get_pixels(event);
                 this.resize_context = {
                     pixels_to_size_x: this.canvas.width - pixels.x,
                     pixels_to_size_y: this.canvas.height - pixels.y,
                     prev_width: this.canvas.width,
                     prev_height: this.canvas.height,
                 };
                 this.last_pixels = null;
                 this.zero_index = null;
             }

             resize_mousemove(event) {
                 if (this.resize_context === null) {
                     return;
                 }
                 var pixels = this.get_pixels(event);
                 var new_width = pixels.x + this.resize_context.pixels_to_size_x;
                 var new_height = pixels.y + this.resize_context.pixels_to_size_y;
                 this.set_size(new_width, new_height);
             }

             resize_mouseup(event) {
                 if (this.resize_context === null) {
                     return;
                 }

                 // Recompute viewport.
                 var new_width = this.canvas.width;
                 var new_height = this.canvas.height;
                 var prev_width = this.resize_context.prev_width;
                 var prev_height = this.resize_context.prev_height;
                 this.origin_r = this.origin_r - ((new_width - prev_width) / prev_width) * this.r_range / 2;
                 this.origin_i = this.origin_i + ((new_height - prev_height) / prev_width) * this.r_range / 2;
                 this.r_range = new_width / prev_width * this.r_range;

                 // Stop resize.
                 this.resize_context = null;

                 // Redraw & re-request.
                 this.draw();
                 this.run_callbacks();
             }

             set_zeros(zeros) {
                 this.finetune_context = null;
                 this.zeros = zeros;
                 this.draw();
                 this.update_finetune_text();
                 this.run_callbacks();
             }

             get_zeros(zeros) {
                 return JSON.parse(JSON.stringify(this.zeros));
             }

             add_callback(callback) {
                 this.callbacks.push(callback);
             }

             keydown(event) {
                 if (this.finetune_context === null) {
                     return;
                 }

                 if (event.key == "+") {
                     this.finetune_scale_by(2.0, event);
                 } else if (event.key == "-") {
                     this.finetune_scale_by(0.5, event);
                 } else if (event.key == "ArrowRight") {
                     this.finetune_move_zero("r", 1, event);
                 } else if (event.key == "ArrowLeft") {
                     this.finetune_move_zero("r", -1, event);
                 } else if (event.key == "ArrowUp") {
                     this.finetune_move_zero("i", 1, event);
                 } else if (event.key == "ArrowDown") {
                     this.finetune_move_zero("i", -1, event);
                 }
             }

             finetune_scale_by(scale, event) {
                 this.finetune_context.step_size *= scale;
                 this.update_finetune_text();
                 event.stopPropagation();
                 event.preventDefault();
             }

             finetune_move_zero(prop, direction, event) {
                 this.zeros[this.finetune_context.zero_index][prop] += direction * this.finetune_context.step_size;
                 this.draw();
                 this.run_callbacks();
                 event.stopPropagation();
                 event.preventDefault();
             }

             update_finetune_text() {
                 var finetune_text = document.getElementById("finetune");
                 if (this.finetune_context === null) {
                     finetune_text.innerHTML = "Finetune: not selected";
                 } else {
                     finetune_text.innerHTML = `Finetune: zero=${this.finetune_context.zero_index}, step=${this.finetune_context.step_size}`;
                 }
             }
         }

         function compute_fps() {
             var now = Date.now();
             while (events.length > 0 && events[0] < now - 1000) {
                 events.shift();
             }
             events.push(now);
             document.getElementById("fps").innerHTML = "FPS: " + events.length;
         }

         function main() {
             const overlay = document.getElementById("overlay");
             const image = document.getElementById("fractal");

             // Force the image to be the same size as the overlay.
             image.width = overlay.width;
             image.height = overlay.height;

             // A square.
             /* var initial_zeros = [
              *     {r: 1, i: 1, red: 255, green: 0, blue: 0},
              *     {r: 1, i: -1, red: 255, green: 255, blue: 0},
              *     {r: -1, i: -1, red: 0, green: 255, blue: 0},
              *     {r: -1, i: 1, red: 0, green: 0, blue: 0},
              * ];*/
             // Tenth roots of unity (all set to the same color, need to press randomize color in UI).
             /* var initial_zeros = [
              *     {r: 1, i: 0, red: 255, green: 255, blue: 255},
              *     {r: 0.809016994374947, i: 0.587785252292473, red: 255, green: 255, blue: 255},
              *     {r: 0.309016994374947, i: 0.951056516295154, red: 255, green: 255, blue: 255},
              *     {r: -0.309016994374947, i: 0.951056516295154, red: 255, green: 255, blue: 255},
              *     {r: -0.809016994374947, i: 0.587785252292473, red: 255, green: 255, blue: 255},
              *     {r: -1, i: 0, red: 255, green: 255, blue: 255},
              *     {r: -0.809016994374947, i: -0.587785252292473, red: 255, green: 255, blue: 255},
              *     {r: -0.309016994374947, i: -0.951056516295154, red: 255, green: 255, blue: 255},
              *     {r: 0.309016994374947, i: -0.951056516295154, red: 255, green: 255, blue: 255},
              *     {r: 0.809016994374947, i: -0.587785252292473, red: 255, green: 255, blue: 255},
              * ];*/
             var initial_zeros = [
                 {r: 1.0, i: 0.0, red: 255, green: 0, blue: 0},
                 {r: -0.5, i: 0.86602540378, red: 0, green: 255, blue: 0},
                 {r: -0.5, i: -0.86602540378, red: 0, green: 0, blue: 255},
             ];
             var resizer = document.getElementById("resize_target");
             const tracker = new ViewportTracker(image, overlay, resizer, initial_zeros);
             const requester = new FractalRequester(image, tracker);

             // When a randomize button is pressed, we pick random new zeros.
             for (var i = 3; i <= 10; i += 1) {
                 const id = "random_zeros_" + i;
                 const curr_i = i;
                 document.getElementById(id).addEventListener("click", function() {
                     var zeros = Array(curr_i).fill().map(() => random_zero());
                     tracker.set_zeros(zeros);
                 });
             }

             // When the randomize color button is pressed, we keep the same zeros but randomize colors.
             document.getElementById("random_colors").addEventListener("click", function() {
                 var zeros = tracker.get_zeros();
                 for (var zero of zeros) {
                     Object.assign(zero, random_color());
                 }
                 tracker.set_zeros(zeros);
             });

             // When UI options change, update.
             document.getElementById("max_iters").addEventListener("input", () => requester.on_change());
             document.getElementById("strategy").addEventListener("input", () => requester.on_change());
             document.getElementById("precision").addEventListener("input", () => requester.on_change());
             document.getElementById("png_encoder").addEventListener("input", () => requester.on_change());
             document.getElementById("handler").addEventListener("input", () => requester.on_change());

             // When save/load is pressed, trigger the corresponding action.
             document.getElementById("save").addEventListener("click", () => requester.save_button());
             document.getElementById("load").addEventListener("click", () => requester.load_button());

             // Don't caputre keystrokes when in text fields.
             document.getElementById("max_iters").addEventListener("keydown", (event) => event.stopPropagation());

             $("#edit_zero").dialog({
                 autoOpen: false,
                 height: 175,
                 width: 250,
                 modal: false,
             });

             $("#save_form").dialog({
                 autoOpen: false,
                 width: 550,
                 modal: true,
             });

             $("#load_form").dialog({
                 autoOpen: false,
                 width: 550,
                 modal: true,
             });

             $(".ui-dialog").on("contextmenu", function(event) {
                 event.stopPropagation();
                 event.preventDefault();
             });

             document.getElementById("zero_colour").addEventListener("input", function() {
                 var zero_index = this.dataset.zero_index;
                 if (zero_index === null || zero_index === undefined) {
                     return;
                 }
                 var hex = this.value;
                 var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                 if (result) {
                     var zeros = tracker.get_zeros();
                     zeros[zero_index].red = parseInt(result[1], 16);
                     zeros[zero_index].green = parseInt(result[2], 16);
                     zeros[zero_index].blue = parseInt(result[3], 16);
                     tracker.set_zeros(zeros);
                 }
             });

             // Force an initial request.
             requester.on_change();
         }

         addEventListener("load", (event) => main());
        </script>
    </head>
    <body>
        <div id="viewport">
            <canvas id="overlay" width="2000px" height="1200px"></canvas>
            <img id="fractal" src="static/hourglass.png"/>
            <div id="resize_container"><div id="resize_target"></div></div>
        </div>
        <p>
            Maximum iterations: <input id="max_iters" type="number" min="1" max="1000" step="1" value="100">
            Computation strategy:
            <select id="strategy">
                <option value="DYNAMIC_BLOCK_THREADED_INCREMENTAL">Vectorized & Multi-Threaded & Incremental</option>
                <option value="DYNAMIC_BLOCK_THREADED">Vectorized & Multi-Threaded</option>
                <option value="DYNAMIC_BLOCK">Vectorized</option>
                <option value="NAIVE">Naive</option>
            </select>
            Numerical percision:
            <select id="precision">
                <option value="SINGLE">Single</option>
                <option value="DOUBLE">Double</option>
            </select>
            PNG Encoder:
            <select id="png_encoder">
                <option value="FPNG">FPNG</option>
                <option value="PNGPP">PNG++ (via libpng)</option>
            </select>
            Handler:
            <select id="handler">
                <option value="ASYNCHRONOUS">Asynchronous</option>
                <option value="PIPELINED">Pipelined</option>
                <option value="SYNCHRONOUS">Synchronous</option>
            </select>
            <input type="checkbox" id="async_params" checked>
            <label>Async param requests</label>
            |
            <span id="fps">FPS: ???</span>
            |
            <span id="finetune">Finetune: not selected</span>
            |
            <button id="save">Save</button>
            <button id="load">Load</button>
        </p>
        <p>
            Random zeros:
            <button id="random_zeros_3">3</button>
            <button id="random_zeros_4">4</button>
            <button id="random_zeros_5">5</button>
            <button id="random_zeros_6">6</button>
            <button id="random_zeros_7">7</button>
            <button id="random_zeros_8">8</button>
            <button id="random_zeros_9">9</button>
            <button id="random_zeros_10">10</button>
            <button id="random_colors">Randomize Colors</button>
        </p>
        <p>
            Left-click-and-drag to pan or to move zeros. Right click to add/edit zeros. Mouse wheel to zoom. Ctrl+left-click-and-drag to rotate around center. Arrow keys and +/- to finetune zero position.
        </p>

        <div id="edit_zero" title="Edit Zero" class="form">
	    <form>
		<fieldset>
                    <input type="color" id="zero_colour" value="#ff0000" style="width:200px;">
		</fieldset>
	    </form>
	</div>

        <div id="save_form" title="Save" class="form">
	    <form>
		<fieldset>
                    Name: <input type="text" id="save_file" size="50">
                    <br/>
                    Scale: <input type="number" id="save_scale" min="1" max="10" value="1">
		</fieldset>
	    </form>
	</div>

        <div id="load_form" title="Load" class="form">
	    <form>
		<fieldset>
                    <select id="load_file"></select>
		</fieldset>
	    </form>
	</div>

    </body>
</html>
